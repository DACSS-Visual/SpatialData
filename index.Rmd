
<br> 
<center><img src="https://i.imgur.com/AbCCpQO.png" width="700"></center>


_____

<a id='TOC'></a>

# Spatial data 

_____

1. [Simple Map](#part1)

2. [Choropleths](#part2)

3. [Merging](#part3) 

4. [Creating spatial points](#part4) 

5. [Interactive maps](#part5) 


_____

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
```


<a id='part1'></a>

# Simple map

A map in our course can be a set of either polygons, lines, or points. In general, each represents a _**layer**_ of spatial information; and several layers form a complex map. Let me bring a map of polygons, where each polygon represents a zip code area:


```{r, eval=TRUE, warning=FALSE, message=FALSE}
rm(list = ls()) # start fresh

library(sf) 
link="https://github.com/DACSS-Visual/SpatialData/raw/main/maps/wazipMap.gpkg"
zipMap=sf::read_sf(link, layer='zips')

# see some rows
head(zipMap)
```

These are the variables available:
```{r}
names(zipMap)
```

Map files have at least two columns, one with a column representing some "id", and another totally compulsory, the column '**geom**', this column gives R the information needed to plot the geometry (line, point, polygon).  This file has come with more columns: one informing the _zip code_ of the geometry in that row (_ZCTA5CE10_); and apart from te other columns, we have the population for the years 2005 and 2015. 

We can see the polygond like this using _ggplot2_:

```{r, warning=FALSE}

library(ggplot2)

base=ggplot(data = zipMap)
base + geom_sf(fill='black')

```

_____


[Go to table of contents.](#TOC)

________________


<a id='part2'></a>

# Choropleths


We call **choropleths** to a colored map representing the distribution of a variable. The colors assign some "ranking" to a polygon with respect to the rest. That is, **fill color is encoding information**. 

Coloring polygons is very easy, but that also may cause interpretation problems. For example let's color the polygons using the population information from 2005 using the [viridis colors](https://sjmgarnier.github.io/viridis/reference/scale_viridis.html): 

```{r}
base=ggplot(data = zipMap)
base + geom_sf(aes(fill=POP2005),color=NA) + scale_fill_viridis_c(direction = -1)
```

The map above is plotting the counts as they are, in their raw form. Plotting counts, in general, tends to a biased viz: the color intensity is correlating visually with the area size (you may review [this article](https://www.esri.com/about/newsroom/arcuser/understanding-statistical-data-for-mapping-purposes/) for further details). 

Counts are not a property of the geometry as a whole, if you split the polygon, the count varies. Then we should do some basic transformations:

## Densities


If you use population _density_ instead of _counts_, you derive a value that will deal better with the correlation of counts and area. Our map does not inform about the area of the polygon, but you can compute it like this:

```{r}
# we need library "units"
zipMap$area_km2=units::drop_units(units::set_units(st_area(st_make_valid(zipMap)),'km2'))

# now compute pop density
zipMap$POP2005_density=zipMap$POP2005/zipMap$area_km2

```


Plotting the density:
```{r}

base=ggplot(data = zipMap) # reload - you have a new variable
choroPop=base + geom_sf(aes(fill=POP2005_density),color=NA,size=0)

# right plot
choroPop + scale_fill_viridis_c(direction = -1)

```

## Rates instead of differences

Let me seek to represent _change_ using a **difference**:

```{r}
# difference as substraction
base + geom_sf(aes(fill=POP2015-POP2005),color=NA,size=0) + 
     scale_fill_viridis_c(direction = -1, option = 'B')

```

This is a better way:

```{r}

# difference as rate
base + geom_sf(aes(fill=POP2015/POP2005),color=NA,size=0) + scale_fill_viridis_c(direction = -1, option = 'B')

```




_____


[Go to table of contents.](#TOC)

________________


<a id='part3'></a>


# Merging data into a map


## The data

The map itself rarely comes with interesting data. So most of the time we need to add data to the map (merge data into the map).

Let's take a look at these data on contributions to Candidates and Political Committees in Washington State. The WA [portal](https://data.wa.gov/) for OpenData has this data on this [website](https://data.wa.gov/Politics/Contributions-to-Candidates-and-Political-Committe/kv7h-kjye).


```{r, eval=TRUE}
linkData='https://github.com/DACSS-Visual/SpatialData/raw/main/data/contriWA.RData'
load(url(linkData))
head(contriWA)
```


Checking the data types:

```{r, eval=TRUE}
str(contriWA,width = 60, strict.width = 'cut')
```
A couple of details:

1. The zip codes are numeric (_contributor_zip_), then:

```{r}
contriWA$contributor_zip=as.character(contriWA$contributor_zip)
```

2. The data is LONG by election year, so let's check the years available and the parties benefitted:

```{r}
table(contriWA$election_year,contriWA$party)
```

Let's keep the Democrats and Republicans for 2012 and 2016:

```{r}
contriWA_1216_RD=contriWA[contriWA$election_year%in% c(2012,2016) & contriWA$party%in% c('DEMOCRAT','REPUBLICAN'),]
```

3. There are categorical levels unused: Notice this:

```{r}
table(contriWA_1216_RD$election_year,contriWA_1216_RD$party)
```

Here we  drop those unused levels:
```{r}
contriWA_1216_RD$party=droplevels(contriWA_1216_RD$party)
```


When you have a way to organize you data by a row that represents a **geographical unit**, you can plot your data on a map. However, in the current format, each row represents a _contribution_ not a _place_; we do not need that, we need a data frame of _contributions_ where each row is a _ZIP code_, and the amount tells us, for example, the average contribution generated in that location. This is an **aggregation** process:

```{r, eval=TRUE, message=FALSE, warning=FALSE}

library(dplyr)
contriWA_1216_RD %>%
  group_by(contributor_zip, election_year, party) %>%
  summarise_at(vars(amount), list(counts=length,
                                  amountPerCap=mean)) ->contribsWA_agg

head(contribsWA_agg)
```

Let me use the _counts_ to compute the proportion of contributions going to a particular party:
```{r}
contribsWA_agg %>%
  group_by(contributor_zip, election_year) %>%

  mutate(percentage = counts / sum(counts) * 100) ->contribsWA_agg
```

Here, we may find that some zips in the contribution data may not be present in the map of zip codes:

```{r}
# not in zipMap 
length(setdiff(contribsWA_agg$contributor_zip,zipMap$ZCTA5CE10))
```
```{r}
# not in contribsWA_agg_W 
length(setdiff(zipMap$ZCTA5CE10,contribsWA_agg$contributor_zip))
```
We will only work with what is common in both.

Since _counts_ in not normalized:

```{r}
# bye!
contribsWA_agg$counts=NULL
```


It is time to merge the data into the map:


```{r, eval=TRUE}

# map to the left!
contrib_zipMap=merge(zipMap,contribsWA_agg,
                     by.x='ZCTA5CE10', by.y='contributor_zip')
# you see
head(contrib_zipMap)
```

There is a new map: *contrib_zipMap*. 


Let's explore the contributions percapita:

```{r, eval=TRUE}
# normalized
base=ggplot() + theme_void() 
base + geom_sf(data=contrib_zipMap,
               aes(fill=amountPerCap)) + 
       scale_fill_viridis_c(direction = -1,
                            na.value = 'red') +
       facet_grid(party~election_year) +
       labs(fill='Contribution PerCap \n (red:no information)') 
```
Notice above that the long format does not have missing values, so a better way to see them would be to create a map of all the zipcodes available:

```{r}
sf_use_s2(FALSE)
plot(st_union(zipMap))
st_make_valid(zipMap)
```



Let's explore the involvement of Republicans using the _proportion_ (while playing with the legend):

```{r, eval=TRUE}
#  normalized
base + geom_sf(data=contrib_zipMap,
               aes(fill=REPUBLICAN_prop),na.rm = T) + 
                scale_fill_viridis_c(direction = -1,na.value = 'red') +
                    facet_grid(~election_year) +
                        labs(fill='Republicans Involvement(%) \n (red:no information)') +
              theme(legend.title = element_text(size=8,
                                                hjust = 0.5),#center
                    legend.position = "bottom",
                    legend.key.width = unit(1, "cm")) + # value to modify
    guides(fill = guide_colourbar(title.position="top"))
```
As you see there are some zipcodes that have no information. Let me keep those to save some processing time:
```{r}
contrib_zipMap[contrib_zipMap$amount_perCap_DEMOCRAT==0,]
```

# Discretizing

Let me organize the DEM contributions into three categories. Let's follow these steps:

1. Make sure you have the package **classInt**:

```{r, eval=TRUE,warning=FALSE,message=FALSE,results='hide'}
#if not:
# install.packages("classInt")
```


2. Cut the Variable. Notice there are several [classification methods](https://www.rdocumentation.org/packages/classInt/versions/0.4-10/topics/classIntervals) to cut a numeric variable into discrete groups: 

```{r}
# how many intervals?
numberOfClasses = 3

library(classInt)

demCuts2012 <- classIntervals(contrib_zipMap[contrib_zipMap$election_year==2012,
                                             ]$amount_perCap_DEMOCRAT,
                          numberOfClasses,style = 'quantile')
demCuts2016 <- classIntervals(contrib_zipMap[contrib_zipMap$election_year==2016,
                                             ]$amount_perCap_DEMOCRAT,
                          numberOfClasses,style = 'quantile')
# the cut breaks for 2012
demCuts2012$brks
```
```{r}
# the cut breaks for 2016
demCuts2016$brks
```


Based on that information, let me customize the cuts:

```{r}
customCuts=c(0,100,1000,5000)
contrib_zipMap$amount_perCap_DEMO_cat=cut(contrib_zipMap$amount_perCap_DEMOCRAT,
                                          breaks=customCuts,include.lowest = T,
                                          dig.lab = 4)

# see the distribution
table(contrib_zipMap$amount_perCap_DEMO_cat,contrib_zipMap$election_year)
```

It is also good to prepare labels for levels:

```{r, eval=TRUE}
# we should prepare a column with simpler names:
theLevels=c("Low","Medium", "High")

#the new var:
contrib_zipMap$amount_perCap_DEMO_catLabel=contrib_zipMap$amount_perCap_DEMO_cat

# as they are factor, we can change level labels
levels(contrib_zipMap$amount_perCap_DEMO_catLabel)=theLevels

# see some
head(contrib_zipMap$amount_perCap_DEMO_catLabel,10)

```

Let's plot (choose  sequential palette from [here](https://ggplot2.tidyverse.org/reference/scale_brewer.html)). Here we use the intervals:

```{r}
base=ggplot(data = zipMap) + theme_light() + 
        geom_sf(fill='black') # black polygon is NO
base + geom_sf(data=contrib_zipMap,
               aes(fill=amount_perCap_DEMO_cat),color=NA) + 
               labs(fill='AMOUNT PERCAPITA\nNo contributions in Black',
                    title='Reduction of democratic counties contributing',
                    subtitle='WA State counties, contribution in 2012 & 2016')+
                    scale_fill_brewer(palette = "YlOrRd") +
                        facet_grid(~election_year)

```
```{r}
base + geom_sf(data=contrib_zipMap,
               aes(fill=amount_perCap_DEMO_cat),color=NA) + 
               labs(fill='LEVEL PERCAPITA\nNo contributions in Black',
                    title='Reduction of democratic counties contributing',
                    subtitle='WA State counties, contribution in 2012 & 2016')+
                    scale_fill_brewer(palette = "YlOrRd") +
                        facet_grid(~election_year)
```

<!-- To avoid the previous problem with _gridExtra_: -->

```{r, echo=FALSE,eval=FALSE}
map2012=base + geom_sf(data=contribWA[contribWA$election_year==2012,],
               aes(fill=amount_perCap_DEMOCRAT_cat)) + 
                    scale_fill_brewer(palette = "YlOrRd") 

map2016=base + geom_sf(data=contribWA[contribWA$election_year==2016,],
               aes(fill=amount_perCap_DEMOCRAT_cat)) + 
                    scale_fill_brewer(palette = "YlOrRd") 

gridExtra::grid.arrange(map2012,map2016,ncol=1)

```



_____


[Go to table of contents.](#TOC)

________________


<a id='part4'></a>

# Plotting coordinates

The dataframe _contriWA_ has columns with coordinates, let's turn that data frame into a _spatial points data frame_, while making sure it has the same  coordinate system as our map:

```{r, eval=TRUE, warning=FALSE, message=FALSE}
library(raster)

mapCRS=crs(zipMap) # projection of our map of zipcodes

contriWA_1216_RD_mapPoints=st_as_sf(contriWA_1216_RD,# data frame
                                    coords = c("Lon","Lat"), # form the data frame
                                    remove = TRUE, # remove lon/lat
                                    crs=mapCRS) # projection for spatial object
```

Our new spatial _points_ dataframe looks the same:
```{r, eval=TRUE}
names(contriWA_1216_RD_mapPoints)
```

But it is not a simple data frame:

```{r, eval=TRUE}
class(contriWA_1216_RD_mapPoints)
```

You can see the geographical details with this:

```{r, eval=TRUE, warning=FALSE}
library(tmaptools)
get_proj4(crs(contriWA_1216_RD_mapPoints))
```


Now, plot the new map of points on top of our WA state map:

```{r}
base=ggplot(data = zipMap) + theme_light() + geom_sf(fill='grey90', color='white') 

contributors=base + 
                geom_sf(data=contriWA_1216_RD_mapPoints, size=0.2,alpha=0.5) + 
                    facet_grid(party~election_year)

contributors
```

_____


[Go to table of contents.](#TOC)

________________


<a id='part5'></a>


# Interactive maps

Interactive maps are useful when you need zooming:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
library(leaflet)

# create palette 
paletteFun=colorFactor(palette = "YlOrRd", 
                       domain = contrib_zipMap$amount_perCap_DEMO_catLabel)

#labels
labels <- sprintf(
  "<strong>%s</strong>",
  zipMap$ZCTA5CE10) %>% lapply(htmltools::HTML)
# the base map
base_map = leaflet() %>% 
            addTiles()%>%
             addPolygons(data = zipMap,
                         fillColor = "black",
                         weight = 0,
                         fillOpacity = 1,
                         label = labels, # se which ones are missing
                         labelOptions = labelOptions(style = list("font-weight" = "normal",
                                                                  padding = "3px 8px"),
                                                     textsize = "15px",
                                                     direction = "auto"))

# the making of the map
final2012 = base_map %>%
         addPolygons(data=contrib_zipMap[contrib_zipMap$election_year==2012,],
                     weight = 0, #thickness of border
                     opacity =  1, # # the closer to 0 the more transparent
                     fillOpacity = 0.8, # color brigthness
                     fillColor = ~paletteFun(amount_perCap_DEMO_catLabel))# coloring
                    

final2012
```

You may need a legend:
```{r, eval=TRUE}
final2012 %>% addLegend(data=contrib_zipMap,
                        position = "bottomright",
                        pal = paletteFun,
                        values = ~amount_perCap_DEMO_catLabel,
                        title = "DEM Contributions<br>(No contributions in black)",
                        opacity = 1) 

```

Let me plot by levels in groups:

```{r, eval=TRUE}
# creating sub maps
contribWA2012=contrib_zipMap[contrib_zipMap$election_year==2012,]
mapLOW=contribWA2012[contribWA2012$amount_perCap_DEMO_catLabel=='Low',]
mapMEDIUM=contribWA2012[contribWA2012$amount_perCap_DEMO_catLabel=='Medium',]
mapGOOD=contribWA2012[contribWA2012$amount_perCap_DEMO_catLabel=='High',]

# plotting

layer1= leaflet() %>% 
            addTiles() %>%
        addPolygons(data=mapLOW,
                    color='yellow',fillOpacity = 1,stroke = F,
                    group = "Low") # LAYER as GROUP

layer1_2= layer1%>%addPolygons(data=mapMEDIUM,
                               color="orange",fillOpacity = 1,stroke = F,
                               group = "Medium")


layer1_2_3= layer1_2%>%addPolygons(data=mapGOOD,
                                   color="red",fillOpacity = 1,stroke = F,
                                   group = "High")

layer1_2_3
```

Let's add a _button_ that helps rezooming:

```{r, eval=TRUE}
textFun="function(btn, map){map.setView([47.751076, -120.740135], 7)}"

final= layer1_2_3 %>%
    addEasyButton(
        easyButton(icon="fa-home", # a symbol
                   title="Zoom to Level 1",
                   onClick=JS(textFun)))

final
```

Here we add an interactive legend using the groups we previously defined:

```{r, eval=TRUE}
final %>% addLayersControl(
        overlayGroups = c('Good','Medium',"High"),
        options = layersControlOptions(collapsed = FALSE))
```


<!-- **Leaflet** is a good option too for spatial points: -->

```{r, eval=TRUE,warning=FALSE}
leaflet(contriWA_1216_RD_mapPoints) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())
```

<!-- The previous map aggregated all the data. Let me split by party for 2016: -->

```{r, eval=TRUE,warning=FALSE, eval=FALSE, echo=FALSE}
# subsetting
sub2016=contriWA_1216_RD_mapPoints[contriWA_1216_RD_mapPoints$election_year==2016,]

leafDEMO2016=leaflet(sub2016[sub2016$party=='DEMOCRAT',]) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())
```

```{r, eval=FALSE, echo=FALSE,warning=FALSE}
# for rezoom
textFun="function(btn, map){map.setView([47.751076, -120.740135], 7)}"


leafREPU2016=leaflet(sub2016[sub2016$party=='REPUBLICAN',]) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())%>%
    # adding the button
    addEasyButton(
        easyButton(icon="fa-home", # a symbol
                   title="Zoom to Level 1",
                   onClick=JS(textFun)))

```

<!-- Now we create our interactive 'facets': -->

```{r, eval=FALSE, echo=FALSE}
library(leafsync)
final2=sync(leafDEMO2016,leafREPU2016,ncol = 2)
final2
```


_____

## Deliverable III (option 1)

This link has data from this [website](https://www.ocpf.us/Home/Index), which, similarly to our previous data, campaign and political finances. This data has a subsample for Boston.
```{r}
linkBoston="https://github.com/DACSS-Visual/SpatialData/raw/refs/heads/main/data/BostonContrib.xlsx"

bostonCont=rio::import(linkBoston)

#see it
head(bostonCont)
```

And you have this map of zip codes:

```{r}
library(sf)
linkZips='https://raw.githubusercontent.com/DACSS-Visual/SpatialData/refs/heads/main/data/zip_codes.json'
bostonZips=sf::read_sf(linkZips)
#see it
head(bostonZips)
```

```{r}
plot(bostonZips[2])
```
You have this variable:
```{r}
summary(bostonCont$Amount)
```


```{r}
tapply(bostonCont$Amount,bostonCont$`Tender Type Description`,summary)
```

Compare in a choropleth the contributions of two tender types (you choose which), by zip zode. The results can be interactive, but it is NOT compulsory.

**NOTE**: You need to aggregate the data from the excel file, and then merged that aggregated data into the map. Then, you can plot the choropleths with the data as it is (countinuous) or discretize it before plotting. 



_____

[Go to table of contents.](#TOC)



