
<br> 
<center><img src="https://i.imgur.com/AbCCpQO.png" width="700"></center>


_____

<a id='TOC'></a>

# Spatial data 

_____

1. [Simple Map](#part1)

2. [Choropleths](#part2)

3. [Merging](#part3) 

4. [Creating spatial points](#part4) 

5. [Interactive maps](#part5) 


_____

```{r klippy, echo=FALSE, include=TRUE}
klippy::klippy(position = c('top', 'right'))
```


<a id='part1'></a>

# Simple map

A map in our course can be a set of either polygons, lines, or points. In general, each represents a _**layer**_ of spatial information; and several layers form a complex map. Let me bring a map of polygons, where each polygon represents a zip code area:


```{r, eval=TRUE, warning=FALSE, message=FALSE}
rm(list = ls()) # start fresh

library(sf) 
link="https://github.com/DACSS-Visual/SpatialData/raw/main/maps/wazipMap.gpkg"
zipMap=sf::read_sf(link, layer='zips')

# see some rows
head(zipMap)
```

As you see, some information has been shared:
```{r}
names(zipMap)
```

The zip code is in the column "_ZCTA5CE10_", and the information to represent the polygon of one zip are (or a particular row) is in "geom". You can see the map like this:

```{r, warning=FALSE}

library(ggplot2)

base=ggplot(data = zipMap)
base + geom_sf()

```

_____


[Go to table of contents.](#TOC)

________________


<a id='part2'></a>

# Choropleths


This maps will represent a variable using a particular set of colors. The colors assign some "ranking" to a polygon with respect to the rest. 

This looks easy, but the area (size) of polygons does interfere in the overall interpretation. So, some *normalization* process is generally needed:

```{r, warning=FALSE}
# no normalization
library(ggplot2)

base=ggplot(data = zipMap)
base + geom_sf(aes(fill=POP2005))
```


```{r}
# normalizing as pop_density
zipMap$area_km2=units::drop_units(units::set_units(st_area(st_make_valid(zipMap)),'km2'))

zipMap$POP2005_density=zipMap$POP2005/zipMap$area_km2

base=ggplot(data = zipMap)
choroPop=base + geom_sf(aes(fill=POP2005_density),color=NA,size=0)

# right plot
choroPop

```

The last map is correct, but we should work on coloring:

```{r}
choroPop+ scale_fill_continuous(trans = 'reverse')
```

A better alternative:

```{r}
choroPop+ scale_fill_viridis_c(direction = -1)
```

Let me seek to represent _change_:

```{r}
# difference as substraction
base + geom_sf(aes(fill=POP2015-POP2005),color=NA,size=0)

```

This is better way:

```{r}

# difference as rate
base + geom_sf(aes(fill=POP2015/POP2005),color=NA,size=0) + scale_fill_viridis_c(direction = -1, option = 'B')

```




_____


[Go to table of contents.](#TOC)

________________


<a id='part3'></a>


# Merging


## The data

Let's work with the data on contributions to Candidates and Political Committees in Washington State. The WA [portal](https://data.wa.gov/) for OpenData has this data on this [website](https://data.wa.gov/Politics/Contributions-to-Candidates-and-Political-Committe/kv7h-kjye).


```{r, eval=TRUE}
linkData='https://github.com/DACSS-Visual/SpatialData/raw/main/data/contriWA.RData'
load(url(linkData))

```


This is what we have:

```{r, eval=TRUE}
str(contriWA,width = 60, strict.width = 'cut')
```

The data is per year, so let's check the years available and the parties benefitted:

```{r}
table(contriWA$election_year,contriWA$party)
```

Let keep the Democrats and Republicans, for 2012 and 2016:

```{r}
contriWA_1216_RD=contriWA[contriWA$election_year%in% c(2012,2016) & contriWA$party%in% c('DEMOCRAT','REPUBLICAN'),]
```

Notice this:

```{r}
table(contriWA_1216_RD$election_year,contriWA_1216_RD$party)
```

We should drop some levels unused:
```{r}
contriWA_1216_RD$party=droplevels(contriWA_1216_RD$party)
```


When you have a way to organize you data by a row that represents a **geographical unit**, you can plot your data on a map. However, in the current format, each row represents a contribution; we do not need that, we need a data frame where each row is ZIP code, and the amount tells us, for example, the average contribution generated in that location. This is an **aggregation** process:

```{r, eval=TRUE, message=FALSE, warning=FALSE}

library(dplyr)
contriWA_1216_RD %>%
  group_by(contributor_zip, election_year, party) %>%
  summarise_at(vars(amount), list(amount_sum=sum,
                                  counts=length,
                                  amount_perCap=mean)) ->contriWA_1216_RD_agg

head(contriWA_1216_RD_agg)
```

The 'party' and 'election_year' gave us a long format, let' get a wide one for 'election_party':

```{r}
library(tidyr)

contriWA_1216_RD_agg %>% 
    pivot_wider(names_from = party,
                values_from = c(amount_sum,
                                counts,
                                amount_perCap)) -> contriWA_1216_RD_agg_wide
    
head(contriWA_1216_RD_agg_wide)
```

Wide shapes create missing values, then:

```{r}
#0 instead of missing
contriWA_1216_RD_agg_wide[is.na(contriWA_1216_RD_agg_wide)] <- 0

```

Let me create _proportions_:

```{r}

totalParty=(contriWA_1216_RD_agg_wide$counts_DEMOCRAT + contriWA_1216_RD_agg_wide$counts_REPUBLICAN)

contriWA_1216_RD_agg_wide$DEMOCRAT_prop=contriWA_1216_RD_agg_wide$counts_DEMOCRAT/totalParty
contriWA_1216_RD_agg_wide$REPUBLICAN_prop=contriWA_1216_RD_agg_wide$counts_REPUBLICAN/totalParty

contriWA_1216_RD_agg_wide$DEMOCRAT_prop=100*round(contriWA_1216_RD_agg_wide$DEMOCRAT_prop,2)
contriWA_1216_RD_agg_wide$REPUBLICAN_prop=100*round(contriWA_1216_RD_agg_wide$REPUBLICAN_prop,2)
```



It is time to merge the data into the map:


```{r, eval=TRUE}
# since
str(zipMap$ZCTA5CE10)
```

Then,
```{r}
contriWA_1216_RD_agg_wide$contributor_zip=as.character(contriWA_1216_RD_agg_wide$contributor_zip)
```


Now we merge:

```{r, eval=TRUE}

# map to the left!
contrib_zipMap=merge(zipMap,contriWA_1216_RD_agg_wide,
                     by.x='ZCTA5CE10', by.y='contributor_zip')
# you see
head(contrib_zipMap)
```

There is a new map: *contrib_zipMap*.


Let's explore the contributions:

```{r, eval=TRUE}
# non normalized
base=ggplot(data = zipMap) + theme_light() + geom_sf(fill='red') 
base + geom_sf(data=contrib_zipMap,
               aes(fill=amount_sum_DEMOCRAT)) + 
                    scale_fill_viridis_c(direction = -1) +
                        facet_grid(~election_year)
                
```

Again, a choropleth should represent, in this case, an average:

```{r, eval=TRUE}
# normalized
base + geom_sf(data=contrib_zipMap,
               aes(fill=amount_perCap_DEMOCRAT)) + 
                scale_fill_viridis_c(direction = -1) +
                    facet_grid(~election_year) +
                        labs(fill='DEM_Contribution PerCap \n (red:no information)')
```

Let's explore the involvement (of Republicans):

```{r, eval=TRUE}
# non normalized
base + geom_sf(data=contrib_zipMap,
               aes(fill=counts_REPUBLICAN)) + 
                    facet_grid(~election_year) +
                        scale_fill_viridis_c(direction = -1)
```

A better version can be a _proportion_:

```{r, eval=TRUE}
#  normalized
base + geom_sf(data=contrib_zipMap,
               aes(fill=REPUBLICAN_prop)) + 
                scale_fill_viridis_c(direction = -1) +
                    facet_grid(~election_year) +
                        labs(fill='REP% \n (red:no information)')
```

# Discretizing

Let me organize the DEM contributions as five categories. Let's follow these steps:

1. Make sure you have:

```{r, eval=TRUE,warning=FALSE,message=FALSE,results='hide'}
# install.packages("classInt")
```


2. Get colors . Notice we are choosing a particular [classification method](https://www.rdocumentation.org/packages/classInt/versions/0.4-10/topics/classIntervals) known as [_jenks_](https://www.rdocumentation.org/packages/classInt/versions/0.4-10/topics/classIntervals): 

```{r, eval=TRUE}
# split (later we will unodo this)
contrib_zipMap2012=contrib_zipMap[contrib_zipMap$election_year==2012,]
contrib_zipMap2016=contrib_zipMap[contrib_zipMap$election_year==2016,]


numberOfClasses = 5

# the vasr to plot 
varToCut2012=contrib_zipMap2012$amount_perCap_DEMOCRAT
varToCut2016=contrib_zipMap2016$amount_perCap_DEMOCRAT


intervals2012 <- classInt::classIntervals(varToCut2012, numberOfClasses,
                            style = "jenks",
                            dataPrecision=2)

intervals2016 <- classInt::classIntervals(varToCut2016, numberOfClasses,
                            style = "jenks",
                            dataPrecision=2)

contrib_zipMap2012$amount_perCap_DEMOCRAT_cat=classInt::findCols(intervals2012,factor = T)
contrib_zipMap2016$amount_perCap_DEMOCRAT_cat=classInt::findCols(intervals2016,factor = T)

# we should prepare a column with simpler names:
newNames=c("veryLow","Low","Good","VeryGood","ExtremelyGood")
contrib_zipMap2012$amount_perCap_DEMOCRAT_cat_labels=contrib_zipMap2012$amount_perCap_DEMOCRAT_cat
contrib_zipMap2016$amount_perCap_DEMOCRAT_cat_labels=contrib_zipMap2016$amount_perCap_DEMOCRAT_cat
# as they are factor, we can change level labels
levels(contrib_zipMap2012$amount_perCap_DEMOCRAT_cat_labels)=newNames
levels(contrib_zipMap2016$amount_perCap_DEMOCRAT_cat_labels)=newNames

# re unite

contrib_zipMap=rbind(contrib_zipMap2012,contrib_zipMap2016)

```

Let's plot (choose  sequential palette from [here](https://ggplot2.tidyverse.org/reference/scale_brewer.html)).

```{r}
# this will give us trouble!

base + geom_sf(data=contrib_zipMap,
               aes(fill=amount_perCap_DEMOCRAT_cat)) + 
                    scale_fill_brewer(palette = "YlOrRd") +
                        facet_grid(~election_year,space = )

```

To avoid the previous problem with _gridExtra_:

```{r}
map2012=base + geom_sf(data=contrib_zipMap[contrib_zipMap$election_year==2012,],
               aes(fill=amount_perCap_DEMOCRAT_cat)) + 
                    scale_fill_brewer(palette = "YlOrRd") 

map2016=base + geom_sf(data=contrib_zipMap[contrib_zipMap$election_year==2016,],
               aes(fill=amount_perCap_DEMOCRAT_cat)) + 
                    scale_fill_brewer(palette = "YlOrRd") 

gridExtra::grid.arrange(map2012,map2016,ncol=1)

```

If we use the simpler labels we created, we have an easy way:

```{r}

DEMmap= base + geom_sf(data=contrib_zipMap,
                       aes(fill=amount_perCap_DEMOCRAT_cat_labels)) + 
                    scale_fill_brewer(palette = "PuBuGn") +
                        labs(fill="DEM contributions perCap") + 
                            facet_wrap(~election_year)
DEMmap
```

_____


[Go to table of contents.](#TOC)

________________


<a id='part4'></a>

# Plotting coordinates

The dataframe _contriWA_ has columns with coordinates, let's turn that data frame into a _spatial points data frame_, while making sure it has the same  coordinate system as our map:

```{r, eval=TRUE, warning=FALSE}
library(raster)

mapCRS=crs(zipMap) # projection of our map

contriWA_1216_RD_mapPoints=st_as_sf(contriWA_1216_RD,# data frame
                                    coords = c("Lon","Lat"), # form the data frame
                                    remove = TRUE, # remove lon/lat
                                    crs=mapCRS) # projection for spatial object
```

Our new spatial _points_ dataframe looks the same:
```{r, eval=TRUE}
names(contriWA_1216_RD_mapPoints)
```

But it is not a simple data frame:

```{r, eval=TRUE}
class(contriWA_1216_RD_mapPoints)
```

You can see the geographical details with this:

```{r, eval=TRUE, warning=FALSE}
library(tmaptools)
get_proj4(crs(contriWA_1216_RD_mapPoints))
```


Now, plot the new map of points on top of our WA state map:

```{r}
base=ggplot(data = zipMap) + theme_light() + geom_sf(fill='grey90', color='white') 

contributors=base + 
                geom_sf(data=contriWA_1216_RD_mapPoints, size=0.2,alpha=0.5) + 
                    facet_grid(party~election_year)

contributors
```

_____


[Go to table of contents.](#TOC)

________________


<a id='part5'></a>


# Interactive maps

Interactive maps are useful as there are small geometries when you need zooming:

```{r, eval=TRUE, message=FALSE, warning=FALSE}
library(leaflet)

# create palette 
paletteFun=colorFactor(palette = "YlOrRd", 
                       domain = contrib_zipMap$amount_perCap_DEMOCRAT_cat_labels)

# the base map
base_map = leaflet() %>% addTiles()

# the making of the map
final2012 = base_map %>%
         addPolygons(data=contrib_zipMap[contrib_zipMap$election_year==2012,],
                     weight = 0, #thickness of border
                     opacity =  1, # # the closer to 0 the more transparent
                     fillOpacity = 0.8, # color brigthness
                     fillColor = ~paletteFun(amount_perCap_DEMOCRAT_cat_labels)) # coloring

final2012
```

You may need a legend:
```{r, eval=TRUE}
final2012 %>% addLegend(data=contrib_zipMap[contrib_zipMap$election_year==2012,],
                        position = "bottomright",
                        pal = paletteFun,
                        values = ~amount_perCap_DEMOCRAT_cat_labels,
                        title = "DEM Contributions",
                        opacity = 1) 

```

Let me plot by levels in groups:

```{r, eval=TRUE}
# creating sub maps
mapBottom=contrib_zipMap[contrib_zipMap$amount_perCap_DEMOCRAT_cat_labels%in%c('VeryLow','Low'),]
mapGood=contrib_zipMap[contrib_zipMap$amount_perCap_DEMOCRAT_cat_labels%in%c('Good'),]
mapTop=contrib_zipMap[contrib_zipMap$amount_perCap_DEMOCRAT_cat_labels%in%c('VeryGood','ExtremelyGood'),]

# plotting
base= leaflet() %>% addProviderTiles("CartoDB.Positron") 

layer1= base %>%
        addPolygons(data=mapBottom,
                    color='yellow',fillOpacity = 1,stroke = F,
                    group = "Bottom")

layer1_2= layer1%>%addPolygons(data=mapGood,color="orange",fillOpacity = 1,stroke = F,
                              group = "Good")


layer1_2_3= layer1_2%>%addPolygons(data=mapTop,color="red",fillOpacity = 1,stroke = F,
                              group = "Top")

layer1_2_3
```

Now let's use those levels in groups with a **home** button that helps rezooming:

```{r, eval=TRUE}
textFun="function(btn, map){map.setView([47.751076, -120.740135], 7)}"

final= layer1_2_3 %>%
    addEasyButton(
        easyButton(icon="fa-home", # a symbol
                   title="Zoom to Level 1",
                   onClick=JS(textFun)))

final
```

We can use an interactive legend, when we have groups (layers):

```{r, eval=TRUE}
final %>% addLayersControl(
        overlayGroups = c("Top",'Good' ,"Bottom"),
        options = layersControlOptions(collapsed = FALSE))
```


**Leaflet** is a good option too for spatial points:

```{r, eval=TRUE,warning=FALSE}
leaflet(contriWA_1216_RD_mapPoints) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())
```

The previous map aggregated all the data. Let me split by party for 2016:

```{r, eval=TRUE,warning=FALSE}
# susetting
sub2016=contriWA_1216_RD_mapPoints[contriWA_1216_RD_mapPoints$election_year==2016,]

leafDEMO2016=leaflet(sub2016[sub2016$party=='DEMOCRAT',]) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())
```

```{r, eval=TRUE,warning=FALSE}
# for rezoom
textFun="function(btn, map){map.setView([47.751076, -120.740135], 7)}"


leafREPU2016=leaflet(sub2016[sub2016$party=='REPUBLICAN',]) %>% 
    addTiles() %>% 
    addCircleMarkers(clusterOptions = markerClusterOptions())%>%
    # adding the button
    addEasyButton(
        easyButton(icon="fa-home", # a symbol
                   title="Zoom to Level 1",
                   onClick=JS(textFun)))

```

Now we create our interactive 'facets':

```{r}
library(leafsync)
sync(leafDEMO2016,leafREPU2016,ncol = 2)
```

_____


[Go to table of contents.](#TOC)



